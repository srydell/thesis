\section{Monte Carlo Simulations}
\label{sec:MonteCarloSims}



\section{Ergodicity}
\label{sec:Ergodicity}

An ergodic system is one where its time average coincides with its ensemble average. 

Intuitively, ergodicity is the assumption that a Markov chain starting from some state $S_a$ with a non zero Boltzmann weight can reach any other state $S_b$ withing a finite number of updates~\cite{Zwanzig:nonequil_stat_mech}.

This is necessary to assume, since otherwise there could be a non zero contribution to the partition function not being sampled by the Markov chain.

\section{Detailed Balance}
\label{sec:DetailedBalance}

Generally, a Markov process can be described through the Master equation

\begin{equation}
    \frac{\mathrm d P_a}{\mathrm d t} = \sum_{a \neq b} \left ( P_b W_{ba} - P_a W_{ab} \right )
\end{equation}

where $P_a$ is the probability to find the system in the state a, and $W_{ab}$ is the transition rate from the state $a$ to $b$. This equation describes the equilibrating of $P_a$ into $P_a^{eq} \propto e^{-\beta E_a}$. The resulting equation is called detailed balance

\begin{equation}
    W_{ba} e^{\beta E_b} = W_{ab} e^{\beta E_a}
\end{equation}

This describes an equal rate of flow into the state $a$ as out of it.

% TODO: Write dividing W_ab and write about acceptance ratio.


\section{Worm Algorithm}
\label{sec:WormAlgorithm}

\section{Testing}
\label{sec:Testing}

Testing is an essential part of writing a simulation. The correctness of the code ensures that the physical model is aptly described. To facilitate the development, a number of coding practices were applied, such as unit testing (Section \ref{sec:UnitTesting}) and regression testing (Section \ref{sec:RegressionTesting}). The tests for the prototypes were written in the Python standard library utility \textit{unittest}, and those for the main simulation used the C++ framework \textit{Catch2}.

\subsection{Unit Testing}
\label{sec:UnitTesting}

Unit testing refers to the practice of isolating a `unit' of code and testing its correctness. A unit can be any small piece of code with an expected behaviour.

This was done by manually calculating the expected output of some code, given some input, and ensuring that the piece of code produced an equivalent result.

The parts of the simulation using a pseudorandom number generator were tested by randomly selecting a set of seeds on which the tests were run upon. The correctness is then assumed from this subset of possible inputs.

When multiple unit tests are tested together, it is called integration testing. This assumes that each unit is correct by itself, and it was used to more closely ressemble the actual simulation.

\subsection{Regression Testing}
\label{sec:RegressionTesting}

Rerunning the relevant tests in a continuous manner after each update is called regression testing. This ensures that, however many unintended consequences were introduced during the update, the expected behaviour of the program is still intact.

This was done by writing a `hook' such that, whenever a piece of code were recompiled, the relevant tests were subsequently compiled and run. With sufficient tests in place, the correctness of the code after the update was assumed.
